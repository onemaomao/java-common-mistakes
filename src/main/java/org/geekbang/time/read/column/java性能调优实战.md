开篇词 | 怎样才能做好性能调优？
1. 扎实的计算机基础
2. 习惯透过源码了解技术本质
3. 善于追问和总结

01 | 如何制定性能调优标准？
为什么要做性能调优？
    好的系统性能调优不仅仅可以提高系统的性能，还能为公司节省资源。
什么时候开始介入调优？
有哪些参考因素可以体现系统的性能？
    CPU,内存,磁盘 I/O,网络,异常,数据库,锁竞争
响应时间
    数据库响应时间,服务端响应时间,网络响应时间,客户端响应时间
吞吐量
    磁盘吞吐量
        一种是 IOPS（Input/Output Per Second）
        另一种是数据吞吐量
    网络吞吐量
计算机资源分配使用率
    通常由 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 来表示资源使用率。
负载承受能力
    当系统压力上升时，你可以观察，系统响应时间的上升曲线是否平缓。这项指标能直观地反馈给你，系统所能承受的负载压力极限。

02 | 如何制定性能调优策略？
性能测试攻略
    1. 微基准性能测试
    2. 宏基准性能测试
       在做性能测试时，还要注意一些问题。
        1. 热身问题
           某个方法或代码块运行得特别频繁时这些代码被认定为热点代码（Hot Spot Code）,通过即时编译器（JIT compiler，just-in-time compiler）把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后存储在内存中，之后每次运行代码时，直接从内存中获取。
        2. 性能测试结果不稳定
        3. 多 JVM 情况下的影响
合理分析结果，制定调优策略
    1. 优化代码
        LinkedList使用Iterator （迭代器）迭代循环该集合而不是使用for
    2. 优化设计
    3. 优化算法
    4. 时间换空间
    5. 空间换时间
    6. 参数调优
        JVM、Web 容器以及操作系统的优化
兜底策略，确保系统稳定性
    什么是兜底策略？
    第一，限流，对系统的入口设置最大访问限制。
    第二，实现智能化横向扩容。
    第三，提前扩容。

03 | 字符串性能优化不容小觑，百M内存轻松存储几十G数据
    高效地使用字符串，可以提升系统的整体性能。
String 对象是如何实现的？
    1. 在 Java6 以及之前的版本中，String 对象是对 char 数组进行了封装实现的对象，主要有四个成员变量：char 数组、偏移量 offset、字符数量 count、哈希值 hash。
    String 对象是通过 offset 和 count 两个属性来定位 char[] 数组，获取字符串。这么做可以高效、快速地共享数组对象，同时节省内存空间，但这种方式很有可能会导致内存泄漏。
    2. 从 Java7 版本开始到 Java8 版本，Java 对 String 类做了一些改变。String 类中不再有 offset 和 count 两个变量了。这样的好处是 String 对象占用的内存稍微少了些，同时，String.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问题。
    3. 从 Java9 版本开始，工程师将 char[] 字段改为了 byte[] 字段，又维护了一个新的属性 coder，它是一个编码格式的标识。
String 对象的不可变性
    Java 这样做的好处在哪里呢？
        第一，保证 String 对象的安全性。假设 String 对象是可变的，那么 String 对象将可能被恶意修改。
        第二，保证 hash 属性值不会频繁变更，确保了唯一性，使得类似 HashMap 容器才能实现相应的 key-value 缓存功能。
        第三，可以实现字符串常量池。在 Java 中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 String str=“abc”；另一种是字符串变量通过 new 形式的创建，如 String str = new String(“abc”)。
String 对象的优化
1. 如何构建超大字符串？
    + 号作为字符串的拼接，被编译器优化成 StringBuilder 的方式
      做字符串拼接的时候，建议显示地使用 String Builder 来提升系统性能
2. 如何使用 String.intern 节省内存？
   使用 intern 方法需要注意的一点是，一定要结合实际场景。因为常量池的实现是类似于一个 HashTable 的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。
3. 如何使用字符串的分割方法？
   慎重使用 Split() 方法，可以用 String.indexOf() 方法代替 Split() 方法完成字符串的分割。如果实在无法满足需求，就在使用 Split() 方法时，对回溯问题加以重视就可以了。

04 | 慎重使用正则表达式
什么是正则表达式？
    正则表达式使用一些特定的元字符来检索、匹配以及替换符合规则的字符串。
    见图:构造正则表达式语法的元字符，由普通字符、标准字符、限定字符（量词）、定位字符（边界字符）组成。
正则表达式引擎
    DFA 自动机（Deterministic Final Automata 确定有限状态自动机）
    NFA 自动机（Non deterministic Finite Automaton 非确定有限状态自动机）。
NFA 自动机的回溯

如何避免回溯问题？
    1. 贪婪模式（Greedy）
    2. 懒惰模式（Reluctant）
    3. 独占模式（Possessive）

正则表达式的优化
1. 少用贪婪模式，多用独占模式
2. 减少分支选择
3. 减少捕获嵌套

总结
    如果使用正则表达式能使你的代码简洁方便，那么在做好性能排查的前提下，可以去使用；如果不能，那么正则表达式能不用就不用，以此避免造成更多的性能问题。

05 | ArrayList还是LinkedList？使用不当性能差千倍
初识 List 接口
    接口继承图
ArrayList 是如何实现的？
    3个测试题
    1.ArrayList 实现类
        实现了 List 接口，继承了 AbstractList 抽象类
        实现了 Cloneable 接口和 Serializable 接口
        实现了 RandomAccess 接口
    2.ArrayList 属性
        数组长度 size、对象数组 elementData、初始化容量 default_capacity 等组成
        elementData 被关键字 transient 修饰了，但 ArrayList 其实是实现了序列化接口
            🌟由于 ArrayList 的数组是基于动态扩增的，所以并不是所有被分配的内存空间都存储了数据
            如果采用外部序列化法实现数组的序列化，会序列化整个数组。
            ArrayList 为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法 writeObject 以及 readObject 来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。
            因此使用 transient 修饰数组，是防止对象数组被其他外部方法序列化。
    3.ArrayList 构造函数
        三个构造函数，第一个是创建 ArrayList 对象时，传入一个初始化值；第二个是默认创建一个空数组对象；第三个是传入一个集合类型进行初始化。
    4.ArrayList 新增元素
        一种是直接将元素加到数组的末尾，另外一种是添加元素到任意位置。
        如果我们在初始化时就比较清楚存储数据的大小，就可以在 ArrayList 初始化时指定数组容量大小，并且在添加元素时，只在数组末尾添加元素，那么 ArrayList 在大量新增元素的场景下，性能并不会变差，反而比其他 List 集合的性能要好。
    5.ArrayList 删除元素
        ArrayList 的删除方法和添加任意位置元素的方法是有些相同的。ArrayList 在每一次有效的删除元素操作之后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。
    6.ArrayList 遍历元素
        由于 ArrayList 是基于数组实现的，所以在获取元素的时候是非常快捷的。

LinkedList 是如何实现的？
    LinkedList 是基于双向链表数据结构实现的，LinkedList 定义了一个 Node 结构，Node 结构中包含了 3 个部分：元素内容 item、前指针 prev 以及后指针 next，代码如下。
    1.LinkedList 实现类
        实现了 List 接口、Deque 接口，同时继承了 AbstractSequentialList 抽象类，LinkedList 既实现了 List 类型又有 Queue 类型的特点；LinkedList 也实现了 Cloneable 和 Serializable 接口，同 ArrayList 一样，可以实现克隆和序列化。
        由于 LinkedList 存储数据的内存地址是不连续的，而是通过指针来定位不连续地址，因此，LinkedList 不支持随机快速访问，LinkedList 也就不能实现 RandomAccess 接口。
    2.LinkedList 属性
        两个重要属性 first/last 属性，其实还有一个 size 属性。我们可以看到这三个属性都被 transient 修饰了，原因很简单，我们在序列化的时候不会只对头尾进行序列化，所以 LinkedList 也是自行实现 readObject 和 writeObject 进行序列化与反序列化。
    3.LinkedList 新增元素
        LinkedList 添加元素的实现很简洁，但添加的方式却有很多种。默认的 add (Ee) 方法是将添加的元素加到队尾，首先是将 last 元素置换到临时变量中，生成一个新的 Node 节点对象，然后将 last 引用指向新节点对象，之前的 last 对象的前指针指向新节点对象。
    4.LinkedList 删除元素
        首先要通过循环找到要删除的元素，如果要删除的位置处于 List 的前半段，就从前往后找；若其位置处于后半段，就从后往前找。
        这样做的话，无论要删除较为靠前或较为靠后的元素都是非常高效的，但如果 List 拥有大量元素，移除的元素又在 List 的中间段，那效率相对来说会很低。
    5.LinkedList 遍历元素
        LinkedList 的获取元素操作实现跟 LinkedList 的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素。但是通过这种方式来查询元素是非常低效的，特别是在 for 循环遍历的情况下，每一次循环都会去遍历半个 List。
        所以在 LinkedList 循环遍历时，我们可以使用 iterator 方式迭代循环，直接拿到我们的元素，而不需要通过循环查找 List。
总结
https://github.com/nickliuchao/collection
    1.ArrayList 和 LinkedList 新增元素操作测试
    2.ArrayList 和 LinkedList 删除元素操作测试
    3.ArrayList 和 LinkedList 遍历元素操作测试

07 | 深入浅出HashMap的设计与优化
常用的数据结构
    数组 链表 哈希表 树
HashMap 的实现结构
    最常用的 Map 类，它是基于哈希表实现的，继承了 AbstractMap 并且实现了 Map 接口。
    哈希冲突的解决:
        开放定址法
            开放定址法很简单，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把 key 存放到冲突位置的空位置上去。这种方法存在着很多缺点，例如，查找、扩容等，所以我不建议你作为解决哈希冲突的首选。
        再哈希函数法
            再哈希法顾名思义就是在同义词产生地址冲突时再计算另一个哈希函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但却增加了计算时间。如果我们不考虑添加元素的时间成本，且对查询元素的要求极高，就可以考虑使用这种算法设计。
        链地址法
            HashMap 则是综合考虑了所有因素，采用链地址法解决哈希冲突问题。这种方法是采用了数组（哈希表）+ 链表的数据结构，当发生哈希冲突时，就用一个链表结构存储相同 Hash 值的数据。
HashMap 的重要属性
    transient Node<K,V>[] table;
    除了 key、value 两个属性外，还定义了一个 next 指针,用于处理哈希冲突
    加载因子（loadFactor）,用来间接设置 Entry 数组（哈希表）的内存空间大小，在初始 HashMap 不设置参数的情况下，默认 LoadFactor 值为 0.75。
    边界值（threshold）,默认边界值为 12
HashMap 添加元素优化
    根据该 key 的 hashCode() 返回值，
    再通过 hash() 方法计算出 hash 值，
    再通过 putVal 方法中的 (n - 1) & hash 决定该 Node 的存储位置。
        hash() 以及 (n-1)&hash 的算法
            简而言之，就是尽量打乱 hashCode 真正参与运算的低 16 位。

HashMap 获取元素优化
HashMap 扩容优化
    JDK1.7 分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。
    JDK 1.8 中的优化，而在 JDK 1.8 中，HashMap 对扩容操作做了优化。由于扩容数组的长度是 2 倍关系，所以对于假设初始 tableSize = 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。
总结
    我们在使用 HashMap 时，可以结合自己的场景来设置初始容量和加载因子两个参数。当查询操作较为频繁时，我们可以适当地减少加载因子；如果对内存利用率要求比较高，我可以适当的增加加载因子。
    我们还可以在预知存储数据量的情况下，提前设置初始容量（初始容量 = 预知数据量 / 加载因子）。这样做的好处是可以减少 resize() 操作，提高 HashMap 的效率。

#########

#########
20 | 磨刀不误砍柴工：欲知JVM调优先了解JVM内存模型
为什么 JVM 在 Java 中如此重要？
    JVM 不仅承担了 Java 字节码的分析（JIT compiler）和执行（Runtime），同时也内置了自动内存分配管理机制。
从了解内存模型开始
    JVM 内存模型主要分为堆、程序计数器、方法区、虚拟机栈和本地方法栈。
1. 堆（Heap）
   最大,共享,划分为新生代和老年代,新生代又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成
   Java6 版本中，永久代在非堆内存区；
   到了 Java7 版本，永久代的静态变量和运行时常量池被合并到了堆中；
   而到了 Java8，永久代被元空间取代了。
2. 程序计数器（Program Counter Register）
   程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。
3. 方法区（Method Area）
   HotSpot 虚拟机使用永久代来实现方法区，但在其它虚拟机中，例如，Oracle 的 JRockit、IBM 的 J9 就不存在永久代一说。因此，方法区只是 JVM 中规范的一部分，可以说，在 HotSpot 虚拟机中，设计人员使用了永久代来实现了 JVM 规范的方法区。
   方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、运行时常量池、字符串常量池。类信息又包括了类的版本、字段、方法、接口和父类等信息。
   方法区与堆空间类似，也是一个共享内存区，所以方法区是线程共享的。
   Java8 为什么使用元空间替代永久代，这样做有什么好处呢？
        官方解释:融合JRockit VM,永久代内存经常不够用或发生内存溢出
4. 虚拟机栈（VM stack）
   Java 虚拟机栈是线程私有的内存空间，它和 Java 线程一起创建。
   当创建一个线程时，会在虚拟机栈中申请一个线程栈，用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。
   每一个方法的调用都伴随着栈帧的入栈操作，方法的返回则是栈帧的出栈操作。
5. 本地方法栈（Native Method Stack）
   本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。
   但本地方法并不是用 Java 实现的，而是由 C 语言实现的。

JVM 的运行原理
示例代码:见文稿的6个步骤
1.JVM 向操作系统申请内存
2.JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。
3.class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值
4.完成上一个步骤后，将会进行最后一个初始化阶段。
5.执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。
6.创建对象，调用非静态方法。

21 | 深入JVM即时编译器JIT，优化Java编译
    前端编译,运行时编译概念
类编译加载执行过程
    过程图:类编译->类加载->类连接->类初始化->运行时编译
类编译
javap反编译,看看一个 class 文件结构中主要包含了哪些信息
    魔数,版本号,常量池,字段表集合,方法表集合(含属性表集合)
        常量池主要记录的是类文件中出现的字面量以及符号引用。
        方法表集合中主要包含一些方法的字节码、方法访问权限（public、protect、prviate 等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM 执行指令以及属性集合等。
类加载
    当一个类被创建实例或者被其它对象引用时，虚拟机在没有加载过该类的情况下，会通过类加载器将字节码文件加载到内存中。
类连接
    验证：验证类符合 Java 规范和 JVM 规范，在保证符合规范的前提下，避免危害虚拟机安全。
    准备：为类的静态变量分配内存，初始化为系统的初始值。
    解析：将符号引用转为直接引用的过程。
类初始化
    类初始化阶段是类加载过程的最后阶段，在这个阶段中，JVM 首先将执行构造器 <clinit> 方法，编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <clinit>() 方法。
    初始化类的静态变量和静态代码块为用户自定义的值，初始化的顺序和 Java 源码从上到下的顺序一致。
    子类初始化时会首先调用父类的 <clinit>() 方法，再执行子类的 <clinit>() 方法
    JVM 会保证 <clinit>() 方法的线程安全，保证同一时间只有一个线程执行。
    JVM 在初始化执行代码时，如果实例化一个新对象，会调用 <init> 方法对实例变量进行初始化，并执行对应的构造方法内的代码。
即时编译
    初始化完成后，类在调用执行过程中，执行引擎会把字节码转为机器码，然后在操作系统中才能执行。在字节码转换为机器码的过程中，虚拟机中还存在着一道编译，那就是即时编译。
    最初，虚拟机中的字节码是由解释器（ Interpreter ）完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为“热点代码”。
    为了提高热点代码的执行效率，在运行时，即时编译器（JIT）会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后保存到内存中。
即时编译器类型
    在 HotSpot 虚拟机中，内置了两个 JIT，分别为 C1 编译器和 C2 编译器，这两个编译器的编译过程是不一样的。
    这两种即时编译也被称为 Client Compiler 和 Server Compiler。
    在 Java7 之前，需要根据程序的特性来选择对应的 JIT，虚拟机默认采用解释器和其中一个编译器配合工作。
    Java7 引入了分层编译，这种方式综合了 C1 的启动性能优势和 C2 的峰值性能优势，我们也可以通过参数 “-client”“-server” 强制指定虚拟机的即时编译模式。分层编译将 JVM 的执行状态分为了 5 个层次：
    在 Java8 中，默认开启分层编译，-client 和 -server 的设置已经是无效的了。如果只想开启 C2，可以关闭分层编译（-XX:-TieredCompilation），如果只想用 C1，可以在打开分层编译的同时，使用参数：-XX:TieredStopAtLevel=1。
    除了这种默认的混合编译模式，我们还可以使用“-Xint”参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；我们还可以使用参数“-Xcomp”强制虚拟机运行于只有 JIT 的编译模式下。
热点探测
    虚拟机为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。
    建立回边计数器的主要目的是为了触发 OSR（On StackReplacement）编译，即栈上编译。
编译优化技术
1. 方法内联
   方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。
   见案例
   见描述，热点方法不一定会被 JVM 做内联优化，如果这个方法体太大了，JVM 将不执行内联操作。而方法体的大小阈值，我们也可以通过参数设置来优化
   热点方法的优化可以有效提高系统性能，一般我们可以通过以下几种方式来提高方法内联：
       通过设置 JVM 参数来减小热点阈值或增加方法体阈值，以便更多的方法可以进行内联，但这种方法意味着需要占用更多地内存；
       在编程中，避免在一个方法中写大量代码，习惯使用小方法体；
       尽量使用 final、private、static 关键字修饰方法，编码方法因为继承，会需要额外的类型检查。
2. 逃逸分析
   逃逸分析（Escape Analysis）是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。
   栈上分配
        在 Java 中默认创建一个对象是在堆中分配内存的，而当堆内存中的对象不再使用时，则需要通过垃圾回收机制回收，这个过程相对分配在栈中的对象的创建和销毁来说，更消耗时间和性能。这个时候，逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。
   HotSpot 虚拟机目前的实现导致栈上分配实现比较复杂，可以说，在 HotSpot 中暂时没有实现这项优化。随着即时编译器的发展与逃逸分析技术的逐渐成熟，相信不久的将来 HotSpot 也会实现这项优化功能。 
3.锁消除
   在局部方法中创建的对象只能被当前线程访问，无法被其它线程访问，这个变量的读写肯定不会有竞争，这个时候 JIT 编译会对这个对象的方法锁进行锁消除。
4.标量替换
   逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。这种编译优化就叫做标量替换。
   -XX:+DoEscapeAnalysis 开启逃逸分析（jdk1.8 默认开启，其它版本未测试）
   -XX:-DoEscapeAnalysis 关闭逃逸分析

    -XX:+EliminateLocks 开启锁消除（jdk1.8 默认开启，其它版本未测试）
    -XX:-EliminateLocks 关闭锁消除
    -XX:+EliminateAllocations 开启标量替换（jdk1.8 默认开启，其它版本未测试）
    -XX:-EliminateAllocations 关闭就可以了
总结

22 | 如何优化垃圾回收机制？
垃圾回收机制
    1. 回收发生在哪里？
       垃圾回收的重点就是关注堆和方法区中的内存了，堆中的回收主要是对象的回收，方法区的回收主要是废弃常量和无用的类的回收。
    2. 对象在什么时候可以被回收？
       一般一个对象不再被引用，就代表该对象可以被回收。
           引用计数算法
           可达性分析算法
       四种引用对象以及功能特点
    3. 如何回收这些对象？
       自动性,不可预期性
GC 算法
    标记清除法
    复制算法
    标记整理算法
    分代搜集算法
    HostSpot中的回收器,使用的回收算法以及各自特点以及设置参数
        Serial New/Serial Old
        ParNew New/ParNew Old
        Parallel Scavenge
        CMS
        G1
GC 性能衡量指标
    吞吐量
    停顿时间
    垃圾回收频率

查看 & 分析 GC 日志
    -XX:+PrintGC 输出 GC 日志
    -XX:+PrintGCDetails 输出 GC 的详细日志
    -XX:+PrintGCTimeStamps 输出 GC 的时间戳（以基准时间的形式）
    -XX:+PrintGCDateStamps 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
    -XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息
    -Xloggc:../logs/gc.log 日志文件的输出路径
    -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs
    GCView工具打开日志文件,GCeasy
GC 调优策略
    1. 降低 Minor GC 频率
       可以通过增大新生代空间来降低 Minor GC 的频率
    2. 降低 Full GC 的频率
       减少创建大对象
       增大堆内存空间
    选择合适的 GC 回收器
       假设我们有这样一个需求，要求每次操作的响应时间必须在 500ms 以内。这个时候我们一般会选择响应速度较快的 GC 回收器，CMS（Concurrent Mark Sweep）回收器和 G1 回收器都是不错的选择。
       而当我们的需求对系统吞吐量有要求时，就可以选择 Parallel Scavenge 回收器来提高系统的吞吐量。

23 | 如何优化JVM内存分配？
JVM 内存分配性能问题
    如果你在线上环境或性能测试时，发现频繁的 GC，且是正常的对象创建和回收，这个时候就需要考虑调整 JVM 内存分配了，从而减少 GC 所带来的性能开销。
对象在堆中的生存周期
    见描述
查看 JVM 堆内存分配
    java -XX:+PrintFlagsFinal -version | grep HeapSize
    jmap -heap 17284
    -XX:+UseAdaptiveSizePolicy
    –XX:NewRatio
    -XX:SurvivorRatio
    JDK1.8 是默认开启 -XX:+UseAdaptiveSizePolicy 配置项
JVM 内存分配的调优过程
    示例代码+AB压测
    分析 GC 日志
    -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/log/heapTest.log
    参考指标
        GC 频率：高频的 FullGC 会给系统带来非常大的性能消耗，虽然 MinorGC 相对 FullGC 来说好了许多，但过多的 MinorGC 仍会给系统带来压力。
        内存：这里的内存指的是堆内存大小，堆内存又分为年轻代内存和老年代内存。首先我们要分析堆内存大小是否合适，其实是分析年轻代和老年代的比例是否合适。如果内存不足或分配不均匀，会增加 FullGC，严重的将导致 CPU 持续爆满，影响系统性能。
        吞吐量：频繁的 FullGC 将会引起线程的上下文切换，增加系统的性能开销，从而影响每次处理的线程请求，最终导致系统的吞吐量下降。
        延时：JVM 的 GC 持续时间也会影响到每次请求的响应时间。
具体调优方法
    调整堆内存空间减少 FullGC：通过日志分析，堆内存基本被用完了，而且存在大量 FullGC，这意味着我们的堆内存严重不足，这个时候我们需要调大堆内存空间。
        java -jar -Xms4g -Xmx4g heapTest-0.0.1-SNAPSHOT.jar
    调整年轻代减少 MinorGC：通过调整堆内存大小，我们已经提升了整体的吞吐量，降低了响应时间。那还有优化空间吗？我们还可以将年轻代设置得大一些，从而减少一些 MinorGC
        java -jar -Xms4g -Xmx4g -Xmn3g heapTest-0.0.1-SNAPSHOT.jar
    设置 Eden、Survivor 区比例：在 JVM 中，如果开启 AdaptiveSizePolicy，则每次 GC 后都会重新计算 Eden、From Survivor 和 To Survivor 区的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量。这个时候 SurvivorRatio 默认设置的比例会失效。
        在 JDK1.8 中，默认是开启 AdaptiveSizePolicy 的，我们可以通过 -XX:-UseAdaptiveSizePolicy 关闭该项配置，或显示运行 -XX:SurvivorRatio=8 将 Eden、Survivor 的比例设置为 8:2。大部分新对象都是在 Eden 区创建的，我们可以固定 Eden 区的占用比例，来调优 JVM 的内存分配性能。
总结
    JVM 内存调优通常和 GC 调优是互补的，基于以上调优，我们可以继续对年轻代和堆内存的垃圾回收算法进行调优。
    建议在进行性能压测后如果没有发现突出的性能瓶颈，就继续使用 JVM 默认参数，起码在大部分的场景下，默认配置已经可以满足我们的需求了。

24 | 内存持续上升，我该如何排查问题？
常用的监控和诊断内存工具
    Linux 命令行工具之 top 命令
    Linux 命令行工具之 vmstat 命令
    Linux 命令行工具之 pidstat 命令
    JDK 工具之 jstat 命令
    JDK 工具之 jstack 命令
    JDK 工具之 jmap 命令
实战演练
    非常好
























06 | Stream如何提高遍历集合效率？
08 | 网络通信优化之I/O模型：如何解决高并发下I/O瓶颈？
09 | 网络通信优化之序列化：避免使用Java序列化
10 | 网络通信优化之通信协议：如何优化RPC网络通信？
11 | 答疑课堂：深入了解NIO的优化实现原理
12 | 多线程之锁优化（上）：深入了解Synchronized同步锁的优化方法
13 | 多线程之锁优化（中）：深入了解Lock同步锁的优化方法
14 | 多线程之锁优化（下）：使用乐观锁优化并行操作
15 | 多线程调优（上）：哪些操作导致了上下文切换？
16 | 多线程调优（下）：如何优化多线程上下文切换？
17 | 并发容器的使用：识别不同场景下最优容器
18 | 如何设置线程池大小？
19 | 如何用协程来优化多线程业务？














