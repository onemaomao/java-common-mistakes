Java 业务开发常见错误 100 例
12 | 异常处理：别让自己在出问题的时候变为瞎子
捕获和处理异常容易犯的错
    不在业务代码层面考虑异常,仅在框架层面粗犷和处理异常
    捕获了异常直接生吞
    丢弃异常原始信息
    抛出异常时不指定任何消息
    除了通过日志正确记录原始异常信息之外,通常还有三种处理方式
        转换,重试,恢复
小心finally中的异常
    try中的异常被finally中异常覆盖,原因一个方法无法出现两个异常
    解决方案
        finally中try catch 然后addSuppressed把finally中的异常附加到主异常上
        使用try-with-resources
千万别把异常定义为静态变量
    结合JVM
提交线程池的任务出了异常会怎样
    线程内遇到异常,线程抛出老线程抛出线程池只能重新创建线程
    没有手动捕获异常进行处理,ThreadGroup帮我们进行了未捕获异常的默认处理,输出打印...见源码
    修复步骤
        1) 线程内部做好异常处理
        2) 设置自定义的异常处理程序作为保底
submit方式提交
    如果不执行get异常会被生吞,原因见FutureTask源码,run执行异常被保存到字段outcome,get的时候抛出
    ps:既然用了submit那么一定是关心执行结果,否则使用execute

整理
Throwable
    常用方法getCause,getMessage,printStackTrace
    子类:Exception,Error
运行时异常: RuntimeException extends Exception
非运行时异常: RuntimeException以外的异常
异常处理机制: 抛出异常、捕获异常
抛出异常: throw、throws
捕获异常: try、catch、finally
异常处理的一般原则:
异常的转译:
异常转译的哲学:
try-with-resources
    AutoCloseable接口
异常屏蔽问题:
    在try-catch-finally代码块中，如果try块、catch块和finally块均有异常抛出，那么最终只能抛出finally块中的异常，而try块和catch块中的异常将会被屏蔽。
    try-with-resources解决
try-catch-finally执行流程:
    fianlly中的return、throw会覆盖try、catch中的return、throw。
Optional优雅解决NPE问题
异常处理规约
    预先检查进行规避，而不应该通过 catch 来处理
    异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低
    对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理
    捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容
    有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务
    不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句
    finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。 说明:如果 JDK7 及以上，可以使用 try-with-resources 方式
    捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。也就是抛出的异常必须是所捕获异常或其子类。这样才能让异常大而化小小而化了
    定义时区分unchecked/checked 异常，避免直接使用RuntimeException抛出， 更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常
    在代码中使用“抛异常”还是“返回错误码”：
        对于公司外的 http/api 开放接口必须 使用“错误码”;
        而应用内部推荐异常抛出;
        跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess、“错误码”、“错误简短信息”。

Effective Java
第 69 条：只针对异常的情况才使用异常
    异常应该只用于异常的情况下；它们永远不应该用于正常的控制流。
    设计良好的 API 不应该强迫它的客户端为了正常的控制流而使用异常 。
第 70 条：对可恢复的情况使用受检异常，对编程错误使用运行时异常
    如果期望调用者能够适当地恢复，对于这种情况就应该使用受检异常。
    用运行时异常来表明编程错误。
    你实现的所有未受检的抛出结构都应该是 RuntimeException 的子类 （直接的或者间接的） 。
    总而言之，对于可恢复的情况，要抛出受检异常；对于程序错误，要抛出运行时异常。不确定是否可恢复，则抛出未受检异常。不要定义任何既不是受检异常也不是运行时异常的抛出类型。要在受检异常上提供方法，以便协助恢复 。
第 71 条：避免不必要地使用受检异常
第 72 条：优先使用标准的异常
    不要直接重用 Exception 、 RuntimeException , Throwable 或者 Error 。
        对待这些类要像对待抽象类一样 。你无法可靠地测试这些异常，因为它们是一个方法可能抛出的其他异常的超类 。
第 73 条：抛出与抽象对应的异常
    更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。
    尽管异常转译与不加选择地从低层传递异常的做法相比有所改进，但是也不能滥用它 。
第 74 条：每个方法抛出的所有异常都要建立文档
    始终要单独地声明受检异常， 并且利用 Javadoc 的＠ throws 标签， 准确地记录下抛出每个异常的条件。
        永远不要声明一个公有方法直接throws Exception(main除外) ，或者更糟糕的是声明它直接“ throws Throwable ”，这是非常极端的例子 。     
    使用 Javadoc 的＠throws标签记录下一个方法可能抛出的每个未受检异常，但是不要使用 throws 关键字将未受检的异常包含在方法的声明中 。
    如果一个类中的许多方法出于同样的原因而抛出同一个异常，在该类的文档注释中对这个异常建立文档，这是可以接受的， 而不是为每个方法单独建立文档 。
第 75 条 ：在细节消息中包含失败 一 捕获信息
    为了捕获失败，异常的细节信息应该包含“对该异常有贡献”的所有参数和域的值。
    千万不要在细节消息中包含密码、密钥以及类似的信息！
第 76 条：努力使失败保持原子性
    一般而言，失败的方法调用应该使对象保持在被调用之前的状态 。 具有这种属性的方法被称为具有失败原子性（ failure atomic ） 。
第 77 条：不要忽略异常
    空的 catch 块会使异常达不到应有的目的
    如果选择忽略异常， catch 块中应该包含一条注释，说明为什么可以这么做，并且变量应该命名为 ignored

深入拆解java虚拟机