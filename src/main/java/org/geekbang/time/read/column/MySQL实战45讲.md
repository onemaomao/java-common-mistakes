01讲基础架构：一条SQL查询语句是如何执行的
MySQL的逻辑架构图
    连接器
        连接器负责跟客户端建立连接、获取权限、维持和管理连接。
    查询缓存
        大多数情况下我会建议你不要使用查询缓存，因为查询缓存往往弊大于利。
        MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。
    分析器
        分析器先会做“词法分析”。
        再做做“语法分析”。
    优化器
        优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。
    执行器
        执行语句。
小结

02讲日志系统：一条SQL更新语句是如何执行的
重要的日志模块：redo log
    WAL(Write-Ahead Logging),先写日志，再写磁盘。
    InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写
重要的日志模块：binlog
    为什么会有两份日志
        因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。
两种日志的三点不同

两阶段提交
怎样让数据库恢复到半个月内任意一秒的状态？
    首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
    然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。
为什么日志需要“两阶段提交”。
    由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。
    这两种方式会有什么问题。
小结
    物理日志redo log和逻辑日志binlog

03讲事务隔离：为什么你改了我还看不见
隔离性与隔离级别
    事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）
    SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。
事务隔离的实现
    在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
        为什么建议你尽量不要使用长事务
            长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。
事务的启动方式

04讲深入浅出索引（上）
索引的常见模型
    哈希表
        哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。
    有序数组
        有序数组在等值查询和范围查询场景中的性能就都非常优秀。
        仅仅看查询效率，有序数组就是最好的数据结构了。二分法就可以快速得到，这个时间复杂度是O(log(N))。
        但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。
        有序数组索引只适用于静态存储引擎。
    搜索树
        二叉
        N叉
    在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。
InnoDB 的索引模型
    在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。
    InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。
    每一个索引在InnoDB里面对应一棵B+树。
    InnoDB的索引组织结构图例。
    索引类型分为主键索引和非主键索引。
        主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。
        非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。
    基于主键索引和普通索引的查询有什么区别？
        如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
        如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。
        也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。
索引维护
    可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。
    自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。
    自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
        而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。
    从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？
        由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。
    显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。
小结

05讲深入浅出索引（下）
    回到主键索引树搜索的过程，称为回表。
    有没有可能经过索引优化，避免回表过程呢？
覆盖索引
    select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。
    覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。
    在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？
        如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。
最左前缀原则
    B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。
    在建立联合索引的时候，如何安排索引内的字段顺序。
        因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
        如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。
索引下推
    见示例

06讲全局锁和表锁：给表加个字段怎么有这么多阻碍
根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。
全局锁
    Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
    全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。
表级锁
MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
表锁的语法是 lock tables … read/write。
    在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。
另一类表级的锁是MDL（metadata lock)。
    MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。
    当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。
    如何安全地给小表加字段？
        首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。
        但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？
            这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。












