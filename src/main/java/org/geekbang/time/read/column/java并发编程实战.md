01 | 可见性、原子性和有序性问题：并发编程Bug的源头
并发程序幕后的故事
核心矛盾:CPU、内存、I/O 设备,三者的速度差异
源头之一：缓存导致的可见性问题
    一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。
源头之二：线程切换带来的原子性问题
    多线程执行count += 1过程中线程切换
源头之三：编译优化带来的有序性问题
    双重检查锁
总结

02 | Java内存模型：看Java如何解决可见性和有序性问题
什么是 Java 内存模型？
    解决可见性、有序性合理的方案应该是按需禁用缓存以及编译优化。
Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。
    具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则/
使用 volatile 的困惑
    示例代码的困惑
Happens-Before 规则
    真正要表达的是：前面一个操作的结果对后续操作是可见的。
    1. 程序的顺序性规则
    2. volatile 变量规则
    3. 传递性
    4. 管程中锁的规则
    5. 线程 start() 规则
    6. 线程 join() 规则
被我们忽视的 final
    java对final优化错误的问题
    逸出问题。只要我们提供正确构造函数没有“逸出”，就不会出问题了。

03 | 互斥锁（上）：解决原子性问题
原子性问题到底该如何解决
    单核CPU时代可以通过禁用线程切换,但是并不适合多核场景
    long 型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作（写高 32 位和写低 32 位)
    “同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。
简易锁模型
    加锁操作:lock()
    临界区:一段代码
    解锁操作:unlock()
改进后的锁模型
    创建保护资源R的锁:LR
    加锁操作:lock(LR)
    临界区:一段代码,包含受保护资源R
    解锁操作:unlock(LR)
Java 语言提供的锁技术：synchronized
    synchronized 关键字可以用来修饰方法，也可以用来修饰代码块
用 synchronized 解决 count+=1 问题
锁和受保护资源的关系
    受保护资源和锁之间的关联关系是 N:1 的关系

04 | 互斥锁（下）：如何用一把锁保护多个资源？
保护没有关联关系的多个资源
保护有关联关系的多个资源
使用锁的正确姿势
总结






